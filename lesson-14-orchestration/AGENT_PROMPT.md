# Промпт для реализации отображения выполняемых действий в UI

## Контекст задачи

У нас есть система оркестрации MCP серверов с LLM агентом. Нужно реализовать отображение выполняемых действий в UI в реальном времени через WebSocket.

## Текущее состояние

- Есть `OrchestrationAgent` который обрабатывает запросы пользователя и вызывает инструменты
- Есть WebSocket контроллер для отправки сообщений клиенту
- Есть клиент на JavaScript для отображения сообщений
- **НО**: Нет отображения промежуточных статусов и описаний выполняемых действий в реальном времени

## Требования к реализации

### 1. Описание выполняемого действия от LLM

LLM должна **ВСЕГДА** возвращать описание выполняемого действия в поле `content` при вызове инструмента. Это описание должно быть информативным и понятным для пользователя.

Примеры правильных описаний:
- "Получаю историю переписки за последние 7 дней из Telegram..."
- "Анализирую полученные сообщения и извлекаю ключевые темы..."
- "Рассчитываю статистику по сообщениям..."
- "Обрабатываю результаты предыдущего инструмента..."
- "Вызываю следующий инструмент для продолжения обработки..."

### 2. Системный промпт для LLM

В системном промпте (`buildSystemPrompt()` в `OrchestrationAgent.kt`) нужно добавить четкие инструкции:

```
⚠️ КРИТИЧЕСКИ ВАЖНО - ОПИСАНИЕ ВЫПОЛНЯЕМОГО ДЕЙСТВИЯ В CONTENT:

При вызове инструмента ты ОБЯЗАНА добавить в поле "content" краткое описание того, что ты делаешь.
Это описание отображается пользователю в UI, чтобы он понимал, что происходит в каждый момент времени.

✅ ПРАВИЛЬНЫЙ ФОРМАТ ОТВЕТА ПРИ ВЫЗОВЕ ИНСТРУМЕНТА:
- Поле "tool_calls" ОБЯЗАТЕЛЬНО должно содержать массив вызовов инструментов
- Поле "content" ОБЯЗАТЕЛЬНО должно содержать краткое описание выполняемого действия
- Это правило действует для КАЖДОГО вызова инструмента: первого, второго, третьего и всех последующих!

⚠️ КРИТИЧЕСКИ ВАЖНО:
- ВСЕГДА добавляй описание в content при КАЖДОМ вызове инструмента
- Описание должно быть понятным и информативным
- НЕ оставляй content пустым при вызове инструмента - это критически важно для пользовательского опыта!
```

### 3. WebSocket сообщения

Нужно отправлять следующие типы сообщений через WebSocket:

#### 3.1. Статус от LLM (описание действия)
```json
{
  "type": "status",
  "message": "Получаю историю переписки за последние 7 дней из Telegram...",
  "timestamp": 1234567890
}
```

#### 3.2. Статус вызова инструмента
```json
{
  "type": "tool_call",
  "toolName": "get_telegram_messages",
  "status": "starting",  // или "success", "error"
  "message": "Инструмент выполнен успешно",  // опционально
  "timestamp": 1234567890
}
```

#### 3.3. Финальный ответ
```json
{
  "type": "final",
  "message": "Финальный ответ пользователю",
  "toolCalls": [...],
  "processingTime": 1234,
  "timestamp": 1234567890
}
```

### 4. Логика в OrchestrationAgent

В методе `processUserMessage()` нужно:

1. **При получении ответа от LLM с tool_calls:**
   - Проверить, есть ли content (описание действия)
   - Если content есть - отправить через `statusCallback` немедленно
   - Если content пустой - отправить дефолтное сообщение "Вызываю инструмент {toolName}..." через `statusCallback`
   - НЕ добавлять предупреждение в историю и НЕ делать перезапрос - это вызывает зацикливание!

2. **При начале вызова инструмента:**
   - Отправить через `toolCallCallback` с status="starting"

3. **При завершении вызова инструмента:**
   - Отправить через `toolCallCallback` с status="success" или "error"

4. **После завершения инструмента:**
   - Если LLM еще не отправила новый статус, можно отправить "Думаю..." через `statusCallback`
   - Но лучше дождаться ответа от LLM в следующей итерации

### 5. WebSocket контроллер

В `WebSocketChatController.kt` нужно:

1. Создать канал для отправки сообщений (`Channel<String>` с `Channel.UNLIMITED`)
2. Запустить корутину-отправитель, которая читает из канала и отправляет через WebSocket
3. В callbacks использовать `trySend` для немедленной неблокирующей отправки в канал
4. Отправлять начальное сообщение "Думаю..." сразу при начале обработки

### 6. Клиентская часть (app.js)

В клиентской части нужно:

1. **При получении сообщения типа "status":**
   - Обновить `.streaming-content` с текстом сообщения
   - Это описание действия от LLM

2. **При получении сообщения типа "tool_call":**
   - Если status="starting" - показать инструмент с оранжевым статусом "Выполняется"
   - Если status="success" - показать инструмент с зеленым статусом "Успешно"
   - Если status="error" - показать инструмент с красным статусом "Ошибка"
   - Обновлять существующий элемент инструмента, если он уже есть

3. **При получении сообщения типа "final":**
   - Обновить сообщение финальным ответом
   - Убрать класс "streaming"

4. **В начале обработки:**
   - Создать сообщение бота
   - Показать "Думаю..." по умолчанию

### 7. Стили (style.css)

Нужно добавить/обновить стили для:

1. **Статус "Выполняется" (starting):**
   - Фон: оранжевый/желтый (#fef3c7 или #fffbeb)
   - Граница: оранжевая (#f59e0b)
   - Текст: темно-оранжевый (#78350f)

2. **Статус "Успешно" (success):**
   - Фон: зеленый (#ecfdf5)
   - Граница: зеленая (#10b981)
   - Текст: темно-зеленый (#047857)

3. **Статус "Ошибка" (error):**
   - Фон: красный (#fef2f2)
   - Граница: красная (#ef4444)
   - Текст: темно-красный (#991b1b)

4. **Время:**
   - Показывать только рядом с сообщением (в `.message-header`)
   - Не показывать в статусе инструмента (только для "starting" можно оставить)

## Порядок реализации

1. **Обновить системный промпт** в `OrchestrationAgent.kt` - добавить инструкции о content
2. **Обновить логику обработки** в `processUserMessage()` - отправлять статусы через callbacks
3. **Создать/обновить WebSocket контроллер** - реализовать отправку сообщений в реальном времени
4. **Обновить клиентскую часть** - обработать все типы сообщений и отобразить статусы
5. **Обновить стили** - добавить цвета для разных статусов

## Важные моменты

- **НЕ создавать циклы с предупреждениями** - если content пустой, просто отправить дефолтное сообщение
- **Отправлять сообщения немедленно** - использовать `trySend` для неблокирующей отправки
- **Сохранять контекст** - все сообщения должны сохраняться в истории диалога
- **Показывать "Думаю..."** - на старте и если нет описания от LLM
- **Обновлять существующие элементы** - не создавать дубликаты инструментов в UI

## Файлы для изменения

1. `server/src/main/kotlin/com/prike/domain/agent/OrchestrationAgent.kt`
   - Обновить `buildSystemPrompt()` - добавить инструкции о content
   - Обновить `processUserMessage()` - логика отправки статусов

2. `server/src/main/kotlin/com/prike/presentation/controller/WebSocketChatController.kt`
   - Создать канал для сообщений
   - Реализовать корутину-отправитель
   - Обновить callbacks для отправки в канал

3. `server/src/main/kotlin/com/prike/presentation/dto/WebSocketDtos.kt`
   - Проверить, что все DTO на месте (StatusUpdate, ToolCallUpdate, FinalResponse)

4. `client/app.js`
   - Обновить обработку WebSocket сообщений
   - Реализовать отображение статусов с правильными цветами

5. `client/style.css`
   - Добавить стили для статусов (оранжевый, зеленый, красный)

## Примеры кода

### Отправка статуса от LLM в OrchestrationAgent:
```kotlin
val llmStatusMessage = assistantMessage.content?.trim()
if (!llmStatusMessage.isNullOrBlank()) {
    statusCallback?.invoke(llmStatusMessage)
} else if (hasToolCalls) {
    // Если content пустой, отправляем дефолтное сообщение
    statusCallback?.invoke("Вызываю инструмент ${toolName}...")
}
```

### Отправка в WebSocket контроллере:
```kotlin
statusCallback = { statusMessage ->
    val statusUpdate = StatusUpdate(statusMessage)
    val messageJson = json.encodeToString(statusUpdate)
    messageChannel.trySend(messageJson)
}
```

### Обработка в клиенте:
```javascript
case 'status':
    updateStreamingBotMessage(currentBotMessageDiv, data.message);
    break;
    
case 'tool_call':
    addToolCallToMessage(currentBotMessageDiv, data.toolName, data.status, data.message);
    break;
```

## Результат

После реализации пользователь должен видеть:
1. Описание действия от LLM в реальном времени ("Получаю данные...", "Анализирую...")
2. Статус каждого инструмента с правильными цветами:
   - ⏳ Выполняется (оранжевый)
   - ✓ Успешно (зеленый)
   - ✗ Ошибка (красный)
3. "Думаю..." на старте и если нет описания от LLM
4. Все обновления в реальном времени без задержек

