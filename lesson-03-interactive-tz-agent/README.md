# Lesson 03: Интерактивный сборщик ТЗ

## Описание

AI-агент для интерактивного сбора требований и создания технического задания (ТЗ). Агент ведет диалог с пользователем, задает уточняющие вопросы, собирает информацию и самостоятельно определяет момент, когда информации достаточно для создания ТЗ.

## Демонстрация

[Видео демонстрации](https://disk.yandex.ru/i/rs-3IYSty-su3g)

## Задание

- Задать ограничение модели, чтобы она сама остановилась
- Опишите в промпте результат, который модель должна собрать и выдать вам ответ
- Как пример можно использовать данные для ТЗ (условно модель должна собрать требования для ТЗ и в какой-то момент переписки вернуть вам ТЗ)

**Результат:** Вы общаетесь и модель выдает вам какой-то результат на основе вашего общения (например, ТЗ)

## Реализация

1. **Управление историей сообщений:**
   - Класс `MessageHistory` хранит весь контекст разговора
   - История передается в каждом запросе к LLM
   - Автоматическая обрезка истории при превышении лимита

2. **Механизм остановки:**
   - System prompt инструктирует модель: когда информации достаточно, вернуть маркер `[TZ_READY]`
   - Агент проверяет ответ на наличие маркера
   - Если маркер найден — парсит ТЗ из JSON ответа

3. **Структурированный вывод:**
   - ТЗ в JSON формате с полями: `title`, `description`, `requirements`, `features`, `constraints`, `timeline`, `targetAudience`, `successCriteria`
   - Полиморфная сериализация через `@JsonClassDiscriminator`

4. **System Prompt:**
   - Четкие инструкции для сбора информации
   - Правила работы: задавать вопросы по одному, уточнять неясные моменты
   - Формат выдачи ТЗ с маркером `[TZ_READY]`

## API Endpoints

### Отправка сообщения в чат
```bash
POST /chat
{
  "message": "Хочу создать мобильное приложение"
}
```

**Ответ - продолжение диалога:**
```json
{
  "type": "continue",
  "message": "Отлично! Расскажите, какое мобильное приложение вы хотите создать?"
}
```

**Ответ - ТЗ готово:**
```json
{
  "type": "tzReady",
  "technicalSpec": {
    "title": "Мобильное приложение для заказа еды",
    "description": "...",
    "requirements": ["Требование 1", "Требование 2"],
    "features": ["Функция 1", "Функция 2"],
    "constraints": ["Ограничение 1"],
    "timeline": "3 месяца",
    "targetAudience": "Пользователи 18-45 лет",
    "successCriteria": ["Критерий 1"]
  }
}
```

### Очистка истории (начать новый диалог)
```bash
DELETE /chat
```

**Ответ:**
```json
{
  "status": "ok",
  "message": "История очищена"
}
```

### Проверка здоровья сервера
```bash
GET /health
```

## Технологии

- **Backend:** Kotlin + Ktor
- **Frontend:** HTML + JavaScript (Vanilla)
- **AI API:** OpenAI или OpenRouter (настраивается)
- **JSON:** Kotlinx Serialization с полиморфной десериализацией

## Быстрый старт

1. Установите Java 17+

2. Убедитесь, что API ключ установлен в `.env` файле в корне проекта:
   ```bash
   OPENAI_API_KEY=your_api_key_here
   ```

3. Настройте AI в `config/ai.yaml` (опционально):
   ```yaml
   ai:
     model: "gpt-3.5-turbo"
     temperature: 0.7
     maxTokens: 2000
   ```

4. Запустите сервер:
   ```bash
   cd server
   ./gradlew run
   ```

5. Откройте браузер: `http://localhost:8080`

## Структура проекта

```
lesson-03-interactive-tz-agent/
├── server/
│   └── src/main/kotlin/com/prike/
│       ├── domain/agent/
│       │   ├── TZAgent.kt              # Специализированный агент для сбора ТЗ
│       │   └── MessageHistory.kt      # Управление историей сообщений
│       ├── data/
│       │   ├── client/
│       │   │   └── OpenAIClient.kt    # HTTP клиент (с поддержкой истории)
│       │   └── dto/
│       │       └── TechnicalSpec.kt    # DTO для ТЗ
│       └── presentation/
│           ├── controller/
│           │   └── ChatController.kt   # Контроллер для чата
│           └── dto/
│               ├── ChatMessageDto.kt   # DTO для сообщения
│               └── ChatResponseDto.kt  # DTO для ответа (полиморфный)
└── client/
    ├── index.html                      # UI для чата
    ├── app.js                          # Логика чата и отображения ТЗ
    └── style.css                       # Стили
```

## Особенности реализации

1. **MessageHistory:**
   - Хранит контекст разговора (system prompt + история диалога)
   - Автоматическая обрезка при превышении лимита (50 сообщений)
   - Метод `clear()` для начала нового диалога

2. **TZAgent:**
   - Использует `MessageHistory` для контекста
   - Проверяет ответ на маркер `[TZ_READY]`
   - Парсит JSON ТЗ из ответа
   - Возвращает `TZAgentResult` (Continue или TZReady)

3. **Механизм остановки:**
   - System prompt явно инструктирует модель вернуть `[TZ_READY]` когда информации достаточно
   - Агент проверяет наличие маркера в ответе
   - Если маркер найден — извлекает и парсит JSON ТЗ

4. **Полиморфная сериализация:**
   - `ChatResponseDto` использует `@JsonClassDiscriminator("type")`
   - Типы: `continue` (продолжение диалога) и `tzReady` (ТЗ готово)

5. **OpenAIClient:**
   - Метод `getCompletionWithHistory()` для работы с историей сообщений
   - Старый метод `getCompletion()` использует новый внутри

## Frontend

### Отображение чата
- История сообщений (пользователь и бот)
- Поле ввода с кнопкой отправки
- Индикатор загрузки
- Обработка ошибок

### Отображение ТЗ
- Структурированное отображение всех полей ТЗ
- Красивое форматирование с секциями
- Скрытие чата при готовности ТЗ

### Кнопка "Начать новый диалог"
- Очищает историю на сервере
- Очищает UI
- Начинает новый диалог

## Важные замечания

- **История сообщений:** Хранится в памяти агента (в объекте `MessageHistory`)
- **System Prompt:** Критически важен для правильной работы агента. Модель должна понимать, когда информации достаточно
- **Маркер остановки:** `[TZ_READY]` должен быть четко описан в system prompt
- **Парсинг JSON:** Агент извлекает JSON из ответа после маркера, используя парсинг скобок
- **Температура модели:** Рекомендуется использовать `temperature: 0.7` для баланса между креативностью и стабильностью

## Примеры использования

**Диалог:**
1. Пользователь: "Хочу создать мобильное приложение"
2. Бот: "Отлично! Расскажите, какое мобильное приложение вы хотите создать?"
3. Пользователь: "Приложение для заказа еды"
4. Бот: "Понятно! Для какой платформы? iOS, Android или обе?"
5. ... (продолжение диалога)
6. Бот: [TZ_READY] {JSON с ТЗ}

## Конфигурация

### config/ai.yaml

```yaml
ai:
  apiUrl: "https://api.openai.com/v1/chat/completions"
  model: "gpt-3.5-turbo"
  temperature: 0.7
  maxTokens: 2000
  requestTimeout: 60
  systemPrompt: null  # Автоматически формируется в AppModule
```

**Важно:** `systemPrompt` в YAML не используется, так как он формируется динамически в `AppModule.buildTZSystemPrompt()`.
